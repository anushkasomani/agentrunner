import express from "express";
import { v4 as uuid } from "uuid";
import { OpenAI } from "openai";
import { z } from "zod";

const OPENAI_API_KEY=""
export const GuardConfigSchema = z.object({
  freshness_s: z.number().int().min(1).default(5),
  slippage_bps_max: z.number().int().min(1).default(50),
  price_dev_max: z.number().min(0).default(0.01),
  fee_sol_max: z.number().min(0).default(0.01),
  notional_usd_max: z.number().min(0).default(5000)
});
export type GuardConfig = z.infer<typeof GuardConfigSchema>;

/** Plan emitted by planner (OpenAI) */
export const PlanSchema = z.object({
  plan_id: z.string(),
  steps: z.array(z.object({
    type: z.enum(["rfp", "skill", "api-service"]),
    capability: z.string().optional(),
    name: z.string().optional(),
    inputs: z.record(z.any()).optional(),
    constraints: z.record(z.any()).optional(),
    budget_usd: z.number().optional(),
    slo: z.record(z.any()).optional()
  }))
});
export type Plan = z.infer<typeof PlanSchema>;

/** Canonical receipt (signed) */
export type Receipt = {
  runner_pubkey: string;
  agent: string;
  task_id: string;
  when_unix: number;
  inputs: Record<string, any>;
  outputs: Record<string, any>;
  protocols: string[];
  fees: { lamports: number; jito_tip_lamports?: number; usdc?: string };
  cost_usd: string;
  guards: {
    freshness_s: number; slippage_bps: number;
    notional_usd: number; price_deviation: number;
    tx_fee_sol: number; verdict: "OK" | "FAIL"
  };
  refs: { pyth_ids?: string[]; quote_response_hash?: string; config_hash?: string };
  sign?: { algo: "ed25519"; sig: string };
};

/** Simple offer from marketplace */
export type Offer = {
  agent_id: string;
  price_usd: number;
  eta_ms: number;
  confidence: number;
  terms?: Record<string, any>;
  proofs?: Record<string, any>;
};

const app = express();
app.use(express.json());

const openai = OPENAI_API_KEY ? new OpenAI({ apiKey: OPENAI_API_KEY }) : null;
const MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";

const SYSTEM = `
You are a planning engine for DeFi agents and API services. Output ONLY JSON matching this schema:
{
"plan_id": "uuid",
"steps": [
{
"type": "rfp" | "skill" | "api-service",
"capability": "swap" |"sip" | "rebalance" | "lp_manage" | "liquidate" | "report_publish" | "data-provider" | "analytics" | "ohlcv-data" | "market-data" | "other",
"name": "rebalance" | "swap" | "add_liquidity" | "remove_liquidity" | "report_publish" | "llm_call" | "api_call",
"inputs": {},
"constraints": {"slippage_bps_max": number, "freshness_s": number},
"budget_usd": number,
"slo": {"p95_ms": number}
}
]
}

Rules:

* For any on-chain action, prefer RFP first (hire best vendor), then use skill steps for execution that the platform can perform.
* For API services, use type "api-service" with name "api_call" or "llm_call".
* If user has selected tools, prioritize using those tools first.
* If no tools are selected or additional services are needed, choose from availableServices based on capability matching and lowest cost.
* For API services, build inputs based on the service's inputParams and queryParams schemas.
* Respect budgets and constraints if given by the user.
* Do NOT include narration; JSON only.
* mention the unit of amount in another field called "unit"
* if the inputMint is sol , then amount should be in lamports
* give the token like usdc , sol in small letter instead of caps so that i'll know that this reponse is generated by ai
* if not api service then mention type as rfp
* always return services before rfp in steps array

Service Selection Logic:
1. If user has selected tools, use those first
2. For remaining requirements, choose from availableServices:
   - ALWAYS match by CAPABILITY field from metadata URI, NOT by service name
   - Look for capability matches like "ohlcv-data", "market-data", "analytics", etc.
   - If multiple services match the same capability, choose the one with lowest price
   - Build inputs according to service's parameter schemas (inputParams/queryParams)
3. If no suitable service exists, use external API calls with appropriate guards

IMPORTANT: When selecting services from availableServices array, always use the "capability" field to match requirements, not the "name" field. The capability field contains the actual service type (e.g., "ohlcv-data", "market-data", "analytics").

Example for SaaS Campaign:
User Goal: "Full campaign: Market research, 1,500-word SEO blog, 10-post social thread, 5 visuals, video script"

If user selected tools = [] (no tools):
{
  "plan_id": "uuid",
  "steps": [
    {
      "type": "api-service",
      "name": "llm_call",
      "inputs": {
        "endpoint": "https://api.perplexity.ai/research",
        "prompt": "Research trending pain points for: {{user_input}}",
        "max_tokens": 1000,
        "guard": { "max_tokens": 1000, "max_latency_ms": 5000, "max_usd": 0.30 }
      },
      "budget_usd": 0.30,
      "slo": { "p95_ms": 5000 }
    },
    {
      "type": "api-service", 
      "name": "llm_call",
      "inputs": {
        "endpoint": "https://rohit-api.com/generate",
        "prompt": "Write a 1,500-word SEO blog using these findings:\\n{{step0.text}}",
        "max_tokens": 2000,
        "guard": { "max_tokens": 2000, "max_latency_ms": 10000, "max_usd": 0.80 }
      },
      "budget_usd": 0.80,
      "slo": { "p95_ms": 10000 }
    },
  // + tweets, images, script agents with similar guards
  ]
  disclaimer: the plan is for the example only, dont use the api-service and their enpoints unless they are actually available on the platform
}
  `;

app.post("/plan", async (req, res) => {
try {
const { goal, context, constraints, budget_usd, selectedTools } = req.body || {};

// Fetch available API services from the platform
let availableServices = [];
try {
  const response = await fetch('http://localhost:3000/api/agents');
  const data = await response.json();
  if (data.ok && data.agents) {
    availableServices = data.agents
      .filter((agent: any) => agent.serviceType === 'api' || agent.service_type === 'api')
      .map((agent: any) => {
        let serviceConfig = {};
        try {
          if (agent.service_store) {
            serviceConfig = JSON.parse(agent.service_store);
          }
        } catch (e) {
          console.warn('Failed to parse service_store for agent:', agent.name);
        }
        
        return {
          id: agent.agentPda || agent.agentId,
          name: agent.name,
          description: agent.description,
          capability: agent.capability,
          endpoint: serviceConfig.endpoint,
          method: serviceConfig.method,
          headers: serviceConfig.headers || {},
          body: serviceConfig.body || null,
          inputParams: serviceConfig.inputParams || {},
          queryParams: serviceConfig.queryParams || {},
          price: parseFloat(agent.charge || '0'),
        };
      });
  }
} catch (error) {
  console.error('Error fetching available services:', error);
}

const user = JSON.stringify({ 
  goal, 
  context, 
  constraints, 
  budget_usd, 
  selectedTools: selectedTools || [],
  availableServices 
});


let text: string | undefined;

if (openai) {
  try {
    const resp = await openai.responses.create({
      model: MODEL,
      input: [
        { role: "system", content: SYSTEM },
        { role: "user", content: user }
      ]
    });
    text = resp.output_text;
  } catch (e) {
    const chat = await openai.chat.completions.create({
      model: MODEL,
      messages: [
        { role: "system", content: SYSTEM },
        { role: "user", content: user }
      ],
      temperature: 0.2
    });
    text = chat.choices[0].message.content || "";
  }
}

let plan;
try { plan = text ? JSON.parse(text) : null; } catch { plan = null; }

if (!plan) {
  // Create a fallback plan based on available services
  const fallbackSteps = [];
  
  // If user has selected tools, use them
  if (selectedTools && selectedTools.length > 0) {
    selectedTools.forEach((tool: any) => {
      fallbackSteps.push({
        type: "api-service",
        capability: tool.category || "utility",
        name: "api_call",
        inputs: {
          endpoint: tool.endpoint,
          method: tool.method,
          headers: tool.headers || {},
          body: tool.body || null,
          // Add sample parameters based on tool type
          ...(tool.category === 'data' ? { symbol: 'btc', timeframe: '1d' } : {}),
        },
        constraints: { freshness_s: 5 },
        budget_usd: tool.price || 0.01,
        slo: { p95_ms: 5000 }
      });
    });
  } else if (availableServices.length > 0) {
    // Use available services
    const dataService = availableServices.find(s => s.capability.includes('data') || s.capability.includes('ohlcv'));
    if (dataService) {
      fallbackSteps.push({
        type: "api-service",
        capability: dataService.capability,
        name: "api_call",
        inputs: {
          endpoint: dataService.endpoint,
          method: dataService.method,
          headers: dataService.headers,
          body: dataService.body,
          ...dataService.queryParams,
        },
        constraints: { freshness_s: 5 },
        budget_usd: dataService.price,
        slo: { p95_ms: 5000 }
      });
    }
  }
  
  // Add default DeFi steps if needed
  if (fallbackSteps.length === 0) {
    fallbackSteps.push(
      {
        type: "rfp",
        capability: "swap.sol (not generated by ai)",
        inputs: { inMint: "So1111...", outMint: "EPjF...", amount: "1000000" },
        constraints: { slippage_bps_max: (constraints?.slippage_bps_max ?? 30), freshness_s: (constraints?.freshness_s ?? 5) },
        budget_usd: budget_usd ?? 0.25,
        slo: { p95_ms: 3000 }
      },
      { type: "skill", name: "rebalance", inputs: { legs: [] } }
    );
  }
  
  plan = {
    plan_id: uuid(),
    steps: fallbackSteps
  };
}

const parsed = PlanSchema.parse(plan);
res.json({ ok: true, plan: parsed });


} catch (e:any) {
res.status(400).json({ ok:false, error: e.message });
}
});


app.listen(7002, ()=> console.log("Planner(OpenAI) listening on :7002"));

